---
title: 【编译原理】四种集合的代码实现
date: 2021-10-04 21:26:58
permalink: /pages/3a457a/
categories:
  - 更多
  - 杂项
tags:
  - 编译原理
---
## 简介
本程序使用java编写，可以求FIRST，FOLLOW，FIRSTVT，LASTVT，以及算符优先表，需要自取，由于代码又臭又长，写着写着就忘记注释了，所以可读性不高，直接复制食用即可

```java
import java.util.*;

/**
 * @author: 倪路
 * Time: 2021/10/4-9:46
 * StuNo: 1910400731
 * Class: 19104221
 * Description:
 *      输入描述    ： # 代表 空集
 *                  ~ 代表末尾
 *                  每个字符之间用空格隔开
 *                  求FIRST、FOLLLOW要求不能左递归，客观的说需要满足LL(1)文法
 */
public class Main {
    private static void handleInput(String[] s){
        for(int i=2;i<s.length;i++){
            if(VN.contains(s[i]))   continue;
            VT.add(s[i]);
        }
    }
    private static Map<String, Set<String>> expressions = new HashMap<>();  // 存储所有产生式
    private static Set<String> VT = new HashSet<>();    // 存储终结符
    private static Set<String> VN = new HashSet<>();    // 存储非终结符
    private static Map<String, Set<String>> FIRST = new HashMap<>();    // 存储FIRST集
    private static Map<String, Set<String>> FOLLOW = new HashMap<>();   // 存储FOLLOW集
    private static Map<String, Set<String>> RELATION = new HashMap<>(); // 存储依赖关系，即更新了一个另一个也需要一起更新
    private static Map<String, Set<String>> FIRSTVT = new HashMap<>();  // 存储FIRSTVT集
    private static Map<String, Set<String>> LASTVT = new HashMap<>();   // 存储LASTVT集
    private static Map<String,Integer> S2I = new HashMap<>();           // 存储最后的算符优先表的字符到行列的映射关系
    private static String[][] VTTABLE = null;                           // 存储算符优先关系表

    private static String begin = "";
    private static Set<String> handleFirst(String cur){
        Set<String> res = new HashSet<>();
        if(VT.contains(cur)){
            res.add(cur);
            return res;
        }
        expressions.get(cur).forEach((s)->{
            String[] s1 = s.split(" ");
            boolean flag = true;
            int i=0;
            while(flag && i<s1.length) {
                if (VT.contains(s1[i])) {
                    res.add(s1[i]);
                    flag=false;
                } else {
                    Set<String> temp = handleFirst(s1[i]);
                    res.addAll(temp);
                    if(!temp.contains("#"))  flag = false;
                    else    i++;
                }
            }
        });
        return res;
    }

    private static void updateAll(String cur){
        RELATION.get(cur).forEach((s)->{
            int pre_size = FOLLOW.get(s).size();
            FOLLOW.get(s).addAll(FOLLOW.get(cur));
            if(FOLLOW.get(s).size()>pre_size){
                updateAll(s);
            }
        });
    }

    private static void handleFollow(String cur){
        expressions.get(cur).forEach((s)->{
            String[] s1 = s.split(" ");
            for(int i=0;i<s1.length;i++) {
                if (VT.contains(s1[i])) continue;
                int pre_size = FOLLOW.get(s1[i]).size();
                // A -->  ...aB
                if (i == s1.length - 1) {
                    FOLLOW.get(s1[i]).addAll(FOLLOW.get(cur));
                    if(FOLLOW.get(s1[i]).size()>pre_size){
                        updateAll((s1[i]));
                    }
                    RELATION.get(cur).add(s1[i]);
                }
                // A -->  ...aBc...
                else if(VT.contains(s1[i+1])){
                    FOLLOW.get(s1[i]).add(s1[i+1]);
                    if(FOLLOW.get(s1[i]).size()>pre_size){
                        updateAll((s1[i]));
                    }
                }
                // A --> ...aBC...
                else{
                    FOLLOW.get(s1[i]).addAll(FIRST.get(s1[i+1]));
                    if(FIRST.get(s1[i+1]).contains("#")){
                        FOLLOW.get(s1[i]).addAll(FOLLOW.get(s1[i+1]));
                        RELATION.get(s1[i+1]).add(s1[i]);
                    }
                    if(FOLLOW.get(s1[i]).size()>pre_size){
                        updateAll((s1[i]));
                    }
                }
            }
        });
    }

    public static Set<String> handleFirstVT(String cur){
        Set<String> res =new HashSet<>();
        expressions.get(cur).forEach((s)->{
            String[] s1 = s.split(" ");
            // T  -> a....
            if(VT.contains(s1[0])){
                res.add(s1[0]);
            }
            // T -> Ra...
            else if(s1.length>1&&VT.contains(s1[1])){
                if(!s1[0].equals(cur))
                    res.addAll(handleFirstVT(s1[0]));
                res.add(s1[1]);
            }
            // T -> R...
            else{
                if(!s1[0].equals(cur))
                    res.addAll(handleFirstVT(s1[0]));
            }
        });
        return res;
    }

    public static Set<String> handleLastVT(String cur){
        Set<String> res =new HashSet<>();
        expressions.get(cur).forEach((s)->{
            String[] s1 = s.split(" ");
            int i = s1.length-1;
            // T -> ...a
            if(VT.contains(s1[i])){
                res.add(s1[i]);
            }
            // T -> ...aR
            else if(s1.length>1&&VT.contains(s1[i-1])){
                if(!s1[i].equals(cur))
                    res.addAll(handleLastVT(s1[i]));
                res.add(s1[i-1]);
            }
            // T -> ...R
            else{
                if(!s1[i].equals(cur))
                    res.addAll(handleLastVT(s1[i]));
            }
        });
        return res;
    }

    public static void handleVtTable(){
        expressions.forEach((k,v)->{
            for (String s : v) {
                String[] s1 = s.split(" ");
                for(int i=0;i<s1.length;i++){
                    if(VT.contains(s1[i])){
                        if(i>0&&VN.contains(s1[i-1])){
                            if(LASTVT.get(s1[i - 1])!=null)
                                for (String s2 : LASTVT.get(s1[i - 1])) {
                                    VTTABLE[S2I.get(s2)][S2I.get(s1[i])]=">";
                                }
                        }
                        if(i<s1.length-1){
                            if(VT.contains(s1[i+1]))
                                VTTABLE[S2I.get(s1[i])][S2I.get(s1[i+1])]="=";
                            else if(i<s1.length-2&&VT.contains(s1[i+2])){
                                VTTABLE[S2I.get(s1[i])][S2I.get(s1[i+2])]="=";
                            }
                            if(FIRSTVT.get(s1[i + 1])!=null)
                                for (String s2 : FIRSTVT.get(s1[i + 1])) {
                                    VTTABLE[S2I.get(s1[i])][S2I.get(s2)]="<";
                                }
                        }
                    }
                }
            }
        });
    }

    public static void soutTable(){
        Formatter formatter = new Formatter(System.out);
        for (int j = 0 ; j < VT.size()*4 ; j++ ){
            System.out.print("-");
        }
        System.out.print("算符优先表");
        for (int j = 0 ; j < VT.size()*4 ; j++ ){
            System.out.print("-");
        }
        System.out.println();
        for(String[] cur : VTTABLE){
            for(String s: cur){
                if(s!=null)
                    formatter.format("%-5s",s);
                else
                    formatter.format("%-5s"," ");
                formatter.format("%-3s","|");
            }
            System.out.println();
            for (int j = 0 ; j < VT.size()*10 ; j++ ){
                System.out.print("-");
            }
            System.out.println();
        }
    }

    public static void soutMap(String msg,Map<String,Set<String>> map){
        for (int j = 0 ; j < VT.size()*4 ; j++ ){
            System.out.print("-");
        }
        System.out.print(msg);
        for (int j = 0 ; j < VT.size()*4 ; j++ ){
            System.out.print("-");
        }
        System.out.println();
        map.forEach((k,v)->{
            System.out.print(k+" : ");
            System.out.println(v);
            System.out.println();
        });
    }

    public static void soutSet(String msg,Set<String> set){
        for (int j = 0 ; j < VT.size()*4 ; j++ ){
            System.out.print("-");
        }
        System.out.print(msg);
        for (int j = 0 ; j < VT.size()*4 ; j++ ){
            System.out.print("-");
        }
        System.out.println();
        set.forEach((s)->{
            System.out.print(s+" ");
        });
        System.out.println();
    }

    public static void main(String[] args) {
        // 这里先直接输入，后面转成前端读入
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入产生式的条数");
        int num = sc.nextInt();
        String[] expression = new String [num+1];
        System.out.println("请依次输入产生式，默认第一个输入的非终结符即为开始字符");
        for(int i=0;i<=num;i++) expression[i] = sc.nextLine();
        begin+=(expression[1].charAt(0));
        for(int i=1;i<=num;i++){
            String[] s1 = expression[i].split(" ");
            VN.add(s1[0]);
            if(expressions.containsKey(s1[0])){
                expressions.get(s1[0]).add(expression[i].substring(5));
            }else{
                expressions.put(s1[0], new HashSet<>());
                expressions.get(s1[0]).add(expression[i].substring(5));
            }
        }
        for(int i=1;i<=num;i++){
            String[] s1 = expression[i].split(" ");
            handleInput(s1);
        }
        int len = VT.size();
        VTTABLE = new String[len+1][len+1];
        final int[] i = {1};
        VT.forEach((s)->{VTTABLE[0][i[0]]=s;
            VTTABLE[i[0]][0]=s;S2I.put(s,i[0]);i[0]++;});

        //// 终结符的FIRST即本身,且终结符无FOLLOW
        VN.forEach((k)->{FOLLOW.put(k,new HashSet<>());RELATION.put(k,new HashSet<>());FIRSTVT.put(k,new HashSet<>());});
        FOLLOW.get(begin).add("~");
        VT.forEach((s)->{Set<String> temp = new HashSet<>();temp.add(s);FIRST.put(s,temp);});
        VN.forEach((s)->{FIRST.put(s,handleFirst(s));FIRSTVT.put(s,handleFirstVT(s));LASTVT.put(s,handleLastVT(s));});
        VN.forEach((s)->{FIRSTVT.put(s,handleFirstVT(s));LASTVT.put(s,handleLastVT(s));});
        VN.forEach(Main::handleFollow);
        FOLLOW.forEach((k,v)->{
            v.remove("#");
        });
        handleVtTable();
        soutSet("VT",VT);
        soutSet("VN",VN);
        soutMap("FOLLOW",FOLLOW);
        soutMap("FIRST",FIRST);
        soutMap("FIRSTVT",FIRSTVT);
        soutMap("LASTVT",LASTVT);
        soutTable();

        //VT.forEach(System.out::println);
        //System.out.println("----------------------");
        //VN.forEach(System.out::println);
        //expressions.keySet().forEach(System.out::println);
        //expressions.values().forEach(System.out::println);
    }
}

```

## 在线网站
目前已将网站部署好，有需要访问即可[点我](http://106.14.196.77:8080)，所有源码在此[Gayhub](https://github.com/3232731490/Compilation-principle.git)