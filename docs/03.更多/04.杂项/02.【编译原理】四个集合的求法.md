---
title: 【编译原理】四个集合的求法
date: 2021-10-02 20:34:22
permalink: /pages/24d67a/
categories:
  - 更多
  - 杂项
tags:
  - 编译原理
---

# 四种集合的求法🚅

> 做题发现，FIRST、FOLLOW、FIRSTVT、LASTVT这四种集合的求法总是会忘记或者搞混，于是决定写下这篇博客来记录以下，以防后面又忘记惹🛹

<!-- more -->

## FIRST🚆

>  First集合最终是对产生式右部的字符串而言的，但其关键是求出非终结符的First集合，由于终结符的First集合就是它自己，所以求出非终结符的First集合后，就可很直观地得到每个字符串的First集合。<br/>
>
>  1. 直接收取：对形如U－a…的产生式（其中a是终结符），把a收入到First(U)中<br/>
>
>  2. 反复传送：对形入U－P…的产生式（其中P是非终结符），应把First(P)中的全部内容传送到First(U)中。<br/>

![规则1](/img/b1.png)

![规则二](/img/b2.png)

例子：

![例](/img/b3.png)

## FOLLOW🚉

>  Follow集合是针对非终结符而言的，Follow(U)所表达的是句型中非终结符U所有可能的后随终结符号的集合，特别地，“#”是识别符号的后随符。<br/>
>
>  1. 直接收取：注意产生式右部的每一个形如“…Ua…”的组合，把a直接收入到Follow(U)中。<br/>
>  2. 直接收取：对形如“…UP…”(P是非终结符)的组合，把First(P)除ε直接收入到Follow(U)中。<br/>
>  3. 反复传送：对形如P－…U的产生式（其中U是非终结符），应把Follow(P)中的全部内容传送到Follow(U)中。(或 P－…UB且First(B)包含ε，则把First(B)除ε直接收入到Follow(U)中，并把Follow(P)中的全部内容传送到Follow(U)中)<br/>

![规则](/img/b4.png)

例子

![img](/img/b5.png)

## 判断某文法是否为LL(1)文法🧪

> 1）文法不含左递归 像这个样子A->Ab是不允许的
>
> 2）对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。
> 即对于A->α1|α2|…|αn
> 要求FIRST（αi）∩ FIRST（αj）=Ø （i≠j）
>
> 3）对于文法中的每个非终结符A，若它存在某个候选首符集包含ε，则
> FIRST（A）∩FOLLOW（A）=Ø

**总结：**

1. 不含左递归

2. 某个非终结符，对于同一个输入，只有一条产生式

3. 若某个非终结符产生式包含ε，则其FIRST集与FOLLOW集不能有交集

   > 单独解释一下这个，若不满足上方这个条件，即FIRST集与FOLLOW有交集，则对于一个输入，就无法确定是以ε还是这个输入来接收，造成二义性

**同时满足上方三个条件的文法即为LL(1)文法**



## FIRSTVT与LASTVT🦺

定义：

![定义](/img/b6.png)

| FIRSTVT(T)    | 非终结符T经过1步或多步推导，得到的最左端终结符，以及左端第二个终结符的集合 |
| ------------- | ------------------------------------------------------------ |
| **LASTVT(T)** | **非终结符T经过1步或多步推导，得到的最右端终结符，以及倒数第二个终结符的集合** |

**求 FIRSTVT 集的步骤：**

（1）若有产生式 T→a 或者 T→Ra…，则 a ∈ FIRSTVT(T)

（2）若 a ∈ FIRSTVT®，且有产生式 T→R…，则 a ∈ FIRSTVT(T)

**求 LASTVT 集的步骤：**

（1）若有产生式 T→…a 或者 T→…aR，则 a ∈ LASTVT(T)

（2）若 a ∈ LASTVT®，且有产生式 T→…R，则 a ∈ LASTVT(T)


> **例题：**<br/>
>
> **已给文法：<br/>
> G[S]:
> S→a|b|(B)
> A→S, A|S
> B→A**
>
> |      | FIRSTVT 集       | LASTVT 集       |
> | ---- | ---------------- | --------------- |
> | S    | {a, b, ( }       | {a, b, ) }      |
> | A    | {a, b, (, 逗号 } | {a, b, ), 逗号} |
> | B    | {a, b, (, 逗号 } | {a, b, ), 逗号} |



##  算法优先表的构造🎞

> + a的优先级低于b
>   **a < b**： 文法中有形如A→…aB…的产生式，则对应于任意b∈FIRSTVT(B)，a < b
> + a的优先级等于b
>   **a = b**： 文法中有形如A→…ab…或者A→…aBb…的产生式
> + a的优先级高于b
>   **a > b**： 文法中有形如A→…Ab…的产生式，则对应于任意a∈LASTVT(A)，a > b
> + 算符的优先关系是有序的
>   + 如果a > b，不能推出b < a
>     + 如果a > b，有可能b > a
>   + 如果a > b， b > c，不一定a > c
>
> 
>
> >填表时注意，横行代表出现在右边的终结符，竖行代表出现在左边的终结符

例题：

![eg](/img/b7.png)

**当一个文法的任意产生式中的两个终结符之间至多满足=，<，>，三种关系之一，则该文法为算符优先文法。**



## 优先函数的构造🎎

>1. 对$\forall$a∈，建立两个符号f<sub>a</sub> , g<sub>a</sub>
>2. 若a=b，则把f<sub>a</sub> , g<sub>b</sub>分为一组
>3. 以第二步的每一个组为一个节点，按照以下优先关系画弧
>
>  + 若a>b，则从f<sub>a</sub> 所在节点画一条有向弧到 g<sub>b</sub>；
>  + 若a<b，则从g<sub>b</sub> 所在节点画一条有向弧到 f<sub>a</sub>；
>
>4. 若图中无环路，则存在优先函数，f(a)，g(b)分别等于从f<sub>a</sub> , g<sub>b</sub>出发的最长路径

例子：

**优先函数实现表达式计算**

| 左/右 | +    | *    | (    | )    | i    | #    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| +     | ·>   | ＜·  | ＜·  | ·>   | ＜·  | ·>   |
| *     | ·>   | ·>   | ＜·  | ·>   | ＜·  | ·>   |
| (     | ＜·  | ＜·  | ＜·  | ＝   | ＜·  |      |
| )     | ·>   | ·>   |      | ·>   |      | ·>   |
| i     | ·>   | ·>   |      | ·>   |      | ·>   |
| #     | ＜·  | ＜·  | ＜·  |      | ＜·  |      |

**由优先表构造优先函数**

| 优先函数 | +    | *    | (    | )    | i    | #    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- |
| f        | 6    | 8    | 2    | 8    | 8    | 1    |
| g        | 4    | 7    | 9    | 2    | 9    | 1    |

