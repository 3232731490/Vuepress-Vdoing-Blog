---
title: Session
date: 2021-09-28 21:44:26
permalink: /pages/5572a3/
categories:
  - 《Hibernate》学习笔记
  - 基础
tags:
  - Hibernate
  - 笔记
---

## Session

### Session概述

1. Session接口是hibernate操作数据库的最主要的接口，它**提供了最基本的保存，更新，删除和加载java对象的方法**
2. **Session具有一个缓存，位于缓存中的对象称为持久化对象，他和数据库中的相关记录对应**
3. 站在持久化的角度，Hibernate把对象分为4种状态：持久化状态，临时状态，游离状态，删除状态。Session的特定方法能使对象从一个状态转换到另一个状态。

### Session缓存

![缓存](https://atts.w3cschool.cn/attachments/image/wk/hibernate/hibernate_cache.jpg)

1. Session接口的实现中包含一系列JAVA集合，这些JAVA集合构成了Session缓存，只要Session实例没有结束生命周期，且没有清理缓存，则存放在它缓存中的对象也不会结束生命周期。
2. Session缓存可减少Hibernate应用程序访问数据库频率

![一级缓存](https://img-blog.csdn.net/20180824195400486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xzeDIwMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3. `flush`: 在提交事务之前会执行，为了是数据库表中的记录和Session缓存中的记录状态保持一致，可能会发送对应的SQL语句，但不会提交事务
   1. 在执行HQL 或 QBC查询时，会先执行flush()操作，以得到数据库中最新的记录
   2. 若记录的**ID** 是由底层数据库使用自增的方式所生成的，则在调用save()方法后，就会立即发出INSERT语句，因为**save**方法后，必须保证对象的ID是存在的

4. `reflush`：会强制发送`SELECT`语句，以使Session缓存中对象的状态和数据库表中的对应记录保持一致

5. `clear`: 清理缓存

### Session核心方法

1. 有关于对象的状态转换

   ![状态转变图](https://img-blog.csdn.net/20180907085421962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjQ1MjE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

2. `save`方法
   1. 使一个临时对象转换为持久化对象
   2. 为对象分配ID
   3. 在`flush`缓存时会发送一条`Insert`语句
   4. 在`save`方法之前的id是无效的
   5. 持久化对象的ID是不能被修改的

3. `Persist`方法
   1. 也会执行`INSERT`操作
   2. 如果在`persist`操作之前，对象已经有ID了，则不会指向`INSERT`方法，而是会抛出异常

4. `get`|`load`方法
   1.  执行`get`方法，会立即加载对象
   2. 执行`load`方法，若不适用该对象，则不会立即执行查询操作，而是返回一个代理对象
   3. `get`是立即检索  `load`是延迟检索
   4. 若数据表中没有对应记录，Session也没有被关闭，get返回null，load在需要使用该对象时则抛出异常
   5. `load`方法可能会抛出懒加载异常: 在需要初始化代理对象之前已经关闭了Session

5. `update` 方法

   1. 若更新一个持久化对象，不要显式调用`update`方法，因为在调用commit方法时，会先执行flush方法

   2. 更新一个游离对象需要显式调用update方法，可以将游离对象变为持久化对象

   3. 注意

      + 无论要更新的游离对象是否和数据库表中数据一致，都会发送update语句

        > 如何避免这种情况？
        >
        > > 在.hbm.xml中的class节点中设置属性 `select-before-upadte`为true，在更新前查询是否和数据库中数据一致，不过通常不设置这个属性 

      + 若数据库表中没有对应记录，但调用了update方法，则抛出异常
      + 当update关联一个游离对象时，如果Session缓存中已经存在相同OID的持久化对象，会抛出异常，因为在同一个Session中不允许有两个对象的OID相同

6. `saveOrUpdate`方法
   1. 同时包含了save和update方法
      + 游离对象执行update
      + 临时对象执行sava

7. `merge`方法
   1. 较复杂，待...

8. `delete`方法
   1. 只要OID和数据库表中一条记录对应就会执行`delete`操作
   2. 若OID在数据表中没有对应记录则抛出异常
   3. 执行操作后不会立马删除，而是会等到flush后再删除数据，此时可以通过再主配置文件中配置

`hibernate.use_identifier_rollback`为true，使删除对象后，将其OID置为null

9. `evict`方法 
   1. 从session缓存中把指定的持久化对象移除

### 其他

1. Hibernate调用存储过程

   + 由于HIbernate没有直接操作存储过程的API，所以需要使用`Connection`来间接操作存储过程，获取`Connection`的方法是`doWork`，需要传入`Work`，这是一个接口，需要重写一个`execute`方法，在这个方法里调用存储过程

     ```java
     session.doWork(new Work() {
         @Override
         public void execute(Connection connection) throws SQLException {
             CallableStatement cs = connection.prepareCall("{call callback()}");
         }
     });
     ```

2. Hibernate与触发器协同工作
   + 在执行update时，如果数据库中有关于update的触发器，不管数据是否变化，都会一直重复调用，解决办法已在上方update第三点的第一条说明
   + 在读取数据库中信息时，可能会出现session缓存与数据库信息不一致的情况，这时可以使用reflush解决，还需要改变数据库的隔离级别，在查询之前同步一下数据库中的最新数据。