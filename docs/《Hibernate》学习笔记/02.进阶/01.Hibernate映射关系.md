---
title: Hibernate映射关系
date: 2021-10-01 15:01:13
permalink: /pages/6a3071/
categories:
  - 《Hibernate》学习笔记
  - 进阶
tags:
  - Hibernate
---

## 映射关系

### 单向多对一映射

1. 单向n--1关联只需从n的一端可以访问1的一端

2. 模型

   ![一对多](https://img-blog.csdnimg.cn/20181122151450343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpZ2dlcmNob25n,size_16,color_FFFFFF,t_70)

   > 一张表中的一条记录对应另一张表中的多条记录；反之不成立。

3. 映射关系

   + 使用`many-to-one`来映射多对一的关联关系

   ```xml
   <many-to-one name="1那一端在n那一端中对应的属性名" class="1的类名" column="1与n在数据库中的外键名"></many-to-one>
   ```

   > column 就是数据库表中的外键

   + 插入顺序的问题

     + 先插入1的一端，再插入多的一端

       > 这种情况只需发送INSERT语句，因为外键关系已经确定

     + 先插入多的一端，再插入一的一端

       > 这种情况除了发送INSERT还要发送UPDATE语句，因为先插入多的一端时，外键关系还无法确定，当把1的一端插入后再更新多的一端的外键关系

     > 推荐先插入1的一端，再插入多的一端

   + 查询的问题

     + 若查询多的一端的一个对象，则默认情况下只查询多中的数据，对应外键关系中的对象不查询

       > 延迟加载，如果用户使用到了与其关联的1中的数据，才发送sql语句对1中的数据进行查询

     + 默认情况下，若在查询多的一端后，在使用1的一端的对象中的数据之前关闭了session，则会发生懒加载异常

       > 在查询多的一端的对象数据时，其关联的一的一端在hibernate中的对象是一个代理对象，所以在使用前关闭了session就会发生异常

   + 更新

     + 正常使用即可

   + 删除

     + 与数据库中外键关联的删除操作类似

       > 在不设定级联关系的情况下，且1这一端的对象有n的对象在引用，则不能直接删除1这一端的对象

       

###　双向一对多映射

1. 双向1--n需要在1的一端可以访问到n的一端，反之亦然

2. 模型

   <img src="https://yqfile.alicdn.com/img_02e2f31c47623f93d7ba0a4a60d8aa2d.png" alt="模型" style="zoom:150%;" />

   > 一的一端存放多的一端对象集合，多的一端存放一的一端的对象信息

3. 映射关系

   + 多对一的映射如上面单向的一致

   + 一对多的集合关系映射如下

     + ```xml
       <set name='一那一端的持久化类中对应多那一端的集合名' table="多那一端的表名">
       	<key column="多的一端的外键列名"></key>
           <one-to-many class="多的一端的类名"/>
       </set>
       ```

   + 插入时的问题

     > 由于插入数据时，1的一端和n的一端都需要维护关联关系，所以不管先插入1的一端还是n的一端都会比单向一对多插入数据时，多出两条UPDATE语句(这两条UPDATE用于维护1对n的管理关系)

     + 如果要避免多出UPDATE，可以在1的一端的set节点设定`inverse=true`，来使1的一端放弃维护关联关系

     + 在一的一端对应的持久化类中，要把存储多的一端的集合进行初始化，防止发生空指针异常

   + 查询时的问题

     + 查询1的一端的数据时，对于多的一端的集合使用延迟加载，此时返回的多的异端的集合对象类型时`Hibernate`内置的集合类型(`org.hibernate.collection.internal.PersistenSet`)，该类型具有延迟加载和存放代理对象的功能，在需要使用到集合中元素才初始化

       > 由于上述返回类型的原因，在一的一端对应的持久化类中，要把存储多的一端的集合声明为接口类型，即声明为`Set`类型，这样才能正确给其赋值<br/><br/>
       >
       > 也有可能抛出懒加载异常

   + 更新删除与单项一对多类似

4. `set`的三个属性

   + `inverse`

     > 指定由哪一方来维护关联关系，设定为true则不维护关联关系，通常给1的一方设定这个属性为true，让多的一方维护关联关系，即可减少update语句

   + `cascade`

     > 设定级联操作
     >
     > > cascade = "delete"<br/>
     > >
     > > 级联删除，删除一的一端时，将所有与之关联的多的一端的也删除
     >
     > > cascade="delete-orphan"<br/>
     > >
     > > 删除多的关联关系，即解除一与多的关联关系，并把多中的数据删除
     >
     > > cascade="save-update"<br/>
     > >
     > > 级联保存，保存一的数据时，将其关联的多的数据也一并保存至数据库

     > 开发时不建议设定该属性，建议使用手工方式处理

   + `order-by`

     > 设定排序规则，和数据库sql语句后的语法一致
     >
     > `order-by="列名 desc|ASC"`



### 一对一关联关系

1. 一张表中的一条记录对应另一张表中的唯一一条记录

2. 模型

   ![模型](https://img-blog.csdnimg.cn/20181122151450417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpZ2dlcmNob25n,size_16,color_FFFFFF,t_70)

3. 基于外键映射

   + 使用`many-to-one` 来映射1-1关联关系

     > `<many-to-one name="关联的属性名" class="关联的类名" column="外键列名" unique="true"/>`
     >
     > > 注意要加上unique唯一约束，这样才可以一对一

   + 在上述配置关联的类中使用`one-to-one`映射关联关系

     > `<one-to-one name="关联的属性名" class="关联的类名" property-ref="与关联的表中的外键关联的字段"/>`

   + 插入时的问题

     > 仍然是注意插入顺序的问题，建议先插入不含外键关系的对象，在插入含外键关系的对象

   + 查询时问题

     + 查询由外键关系的对象时

       > 默认情况下对关联属性使用懒加载，也会有懒加载异常的问题

     + 查询不含外键的对象时

       > 此时要一并将与其关联的对象查出，因为这个不含外键的对象中没有与之关联的对象的信息，所以无法在使用懒加载机制(在含有外键关系的对象中有不含外键的对象的id属性，使用懒加载机制时可以通过这个id来查询到对应数据)

4. 基于主键映射

   + 映射策略为

     > 将一端的主键生成器使用`foreign`策略，表明根据**对方**的主键来生成自己的主键，自己不独立生成主键

   + `generator`

     ```xml
     <!--指定生成策略为foreign-->
     <generator class="foreign">
         <!--property指定当前使用哪一个属性的主键作为外键-->
     	<param name="property">
         	关联的类的在本类中的属性名
         </param>
     </generator>
     
     <one-to-one name="关联的类的在本类中的属性名" class="关联的类名"  constraint="true"></one-to-one>
     <!--constraint=true  指定当前foreign主键生成器上添加外键约束-->
     ```

     ```xml
     <!--上述所对应关联的类的配置文件中-->
     <one-to-one name="与其关联的类在本类中的属性名" class="关联的类名"></one-to-one>
     ```

   + 插入时的问题

     > 由于存在一个外键约束，必须要先插入不含外键约束的对象，由这个对象来生成有外键约束的对象的主键
     >
     > > 这里如果先插入的有外键约束的对象，hibernate也会自动调换顺序，先把不含外键约束的对象插入

### 映射多对多关系

#### 单向多对多

1. 一张表中的一条记录对应另一张表中的多条记录；反之也成立。

2. 模型

   ![模型](https://img-blog.csdnimg.cn/20181122151450405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpZ2dlcmNob25n,size_16,color_FFFFFF,t_70)

3. 映射关系

   + 在有关联关系的其中一张表的持久化类属性中加入另一个类的集合

   + 在其映射配置文件中作如下配置

     ```xml
     <set name="集合名" table="生成的中间表名">
     	<key>
         	<column name="中间表中的对应本类的主键的列名"/>
         </key>
         <many-to-many class="关联的类名" column="中间表中对应关联的表的主键的列名"></many-to-many>
     </set>
     ```

     

#### 双向多对多

1. 在上述单向多对多的基础上，在另一张表的实体类中也要加入另一个类的属性
2. 并且，配置文件中也要加入`set`，其中的配置项key要与上述单向中配置的交叉相同
3. **注意**： 双向多对多要在其中一个set中加上`inverse=true`，否则会发生主键冲突



### 继承映射

1. 使用subclass元素的继承映射

   + 在父类的映射配置文件中加入属性`subclass`，并配置辨别者列(用于区分是子类还是父类)

     > `<discriminator column="辨别者的列名" type=”辨别者的类型“>`

     ```xml
     <subclass name="子类名" discriminator-value="子类标识">
         <property name="子类的属性" type="类型" column="对应列名"></property>
     </subclass>
     ```

     > 同时也要在开始的class标签中加入父类的`discriminator-value`

   + 插入操作

     + 子类和父类对象都插入到同一张表中
     + 辨别者列由Hibernate自动维护

   + 查询操作

     + 查询子类以及父类记录都只需要查询一张表

   + 缺点

     + 使用了辨别者列
     + 子类独有的字段不能添加非空约束
     + 若继承层次较深，则数据表的字段也会较多

2. 使用`joined-subclass`

   + 在父类的映射配置文件中加入属性`joined-subclass`

     ```xml
     <joined-subclass name="子类类名" table="子类对应表名">
     	<key column="子类的主键名"></key>
         <property name="子类属性名" type="类型" column="对应列名"></property>
     </joined-subclass>
     ```

   + 插入操作

     + 插入子类对象至少要插入到两张表中

   + 查询操作

     + 查询父类记录，做一个左外连接查询
     + 查询子类记录，做一个内连接查询

   + 优点

     + 不需要使用辨别者列
     + 子类独有的字段可以添加非空约束
     + 没有冗余的字段

3. 使用`union-subclass`

   + 在父类的映射配置文件中加入属性`union-subclass`

     ```xml
     <union-subclass name="子类类名" table="表名">
     	<property name="属性名" column="对应列名" type="类型"></property>
     </union-subclass>
     ```

   + 插入操作

     + 对于子类只需要插入到一张表中

   + 查询操作

     + 查询父类记录，需要把父表和子表汇总到一起
     + 查询子类记录，只需要查询一张表

   + 优点

     + 无需使用辨别者列
     + 子类独有的字段能添加非空约束

   + 缺点

     + 存在冗余的字段
     + 更新父表字段时效率较低(会把子类的所有属性一起更新)
