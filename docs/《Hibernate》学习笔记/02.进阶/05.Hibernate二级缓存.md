---
title: Hibernate二级缓存
date: 2021-10-01 19:29:33
permalink: /pages/643b95/
categories:
  - 《Hibernate》学习笔记
  - 进阶
tags:
  - Hibernate
---

## Hibernate二级缓存

> Hibernate提供两个级别的缓存
>
> > 一级缓存即Session级别的缓存，它是数据事务范围的缓存，这一级别的缓存由hibernate管理
>
> > 二级缓存时SessionFactory级别的缓存，它是属于进程范围的缓存
> >
> > > 第一类：内置缓存<br/>
> > >
> > > Hibernate自带的，不可卸载。
> >
> > >第二类：外置缓存
> > >
> > >一个可配置的缓存插件，默认不启用

+ 适合放到二级缓存中的数据
  + 很少被修改
  + 不是很重要的数据，允许出现偶尔的并发问题
+ 不适合放入二级缓存的数据
  + 经常被修改
  + 财务数据，绝对不允许出现并发问题
  + 与其他应用程序共享的数据

![内部结构](http://c.biancheng.net/uploads/allimg/190627/5-1Z62G44352462.png)

### 二级缓存的并发访问策略

>  Hibernate二级缓存的并发访问策略有四种：只读（read-only)、非严格读写（nonstrict-read-write)、读写(read-write）和事务(transactional)。但是目前还没有二级缓存提供者完全支持所有的并发访问策略。<br/>
>
>只读（read-only)： 对于永远不会被修改的数据可以采用这种并发访问策略，它的并发性能是最高的。但必须保证数据不会被修改，否则就会出错。<br/>
>非严格读写（nonstrict-read-write): 非严格读写不能保证缓存与数据库中数据的一致性，如果存在两个事务并发地访问缓存数据的可能，则应该为该数据配置一个很短的过期时间，以减少读脏数据的可能。对于极少被修改，并且可以容忍偶尔脏读的数据可以采用这种并发策略。<br/>**读写**（read-write)： 读写策略提供了“read committed"数据库隔离级别。对于经常被读但很少修改的数据可以采用这种策略，它可以防止读脏数据。<br/>
>事务（transactional）： 它提供了Repeatable Read事务隔离级别。它可以防止脏读和不可重复读这类的并发问题。<br/>



### 管理Hibernate的二级缓存

#### 1）EHCache

可作为进程范围内的缓存，存放数据的物理介质可以是内存或硬盘，对 Hibernate 的查询缓存提供了支持。

#### 2）OpenSymphony OSCache

可作为进程范围内的缓存，存放数据的物理介质可以是内存或硬盘；它提供了丰富的缓存数据过期策略，并且对 Hibernate 的查询缓存提供了支持。

#### 3）SwarmCache

可作为集群范围内的缓存，但不支持 Hibernate 的查询缓存。

#### 4）JBossCache

可作为集群范围内的缓存，支持 Hibernate 的查询缓存。

| 二级缓存的常用插件 | 只读型 | 非严格读写 | 读写型 | 事务型 |
| ------------------ | ------ | ---------- | ------ | ------ |
| **EHCache**        | √      | √          | √      |        |
| OSCache            | √      | √          | √      |        |
| SwarmCache         | √      | √          |        |        |
| JBossCache         | √      |            |        | √      |



### 使用二级缓存

1. 导入EHCache的jar包

2. 配置EHCache的配置文件

3. 配置hibernate主配置文件

   ```xml
   <!--启用二级缓存-->
   <property name="cache.use_second_level_cache">true</property>
   
   <!--配置使用的二级缓存的产品-->
   <property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
   
   <!--配置对哪个类启用二级缓存-->
   <class-cache usage="read-write" class="类名"></class-cache></class-cache>
   
   <!--配置集合类别的二级缓存-->
   <collection-cache usage="read-write" collection="哪个类的哪个集合"></collection-cache>
   <class-cache usage="read-write" class="集合中的元素类名"></class-cache></class-cache>
   ```

   > 也可以在.hbm.xml文件中配置`<cache usage=""/>`来实现
   >
   > > 在配置集合类别的二级缓存时还需要给集合元素的持久化类也实现二级缓存



### EHCache中的配置

1. `diskStore`

   > 指定目录，当EHCache把数据写到硬盘上，就写到这个目录中
   >
   > > `<diskstore path="目录">`

2. `defalutCache`

   > 设置缓存的默认数据过期策略

3. `cache`

   > 设定具体的命名缓存的数据过期策略。每个命名缓存代表一个缓存区域
   >
   > 命名规则为：对于类：以类的全限定名称命名<br/>
   >
   > ​						对于集合：以类名加属性名命名

| 名称                       | 说明                                                |
| -------------------------- | --------------------------------------------------- |
| `<diskStore>`元素          | 用于设置缓存数据文件的存储目录                      |
| `<defaultCache>`元素       | 用于设置缓存的默认数据过期策略。                    |
| `<cache>`元素              | 用于设置具体的命名缓存的数据过期策略。              |
| `maxElementsInMemory` 属性 | 用于设置缓存对象的最大数目                          |
| `eternal` 属性             | 用于指定是否永不过期，true 为不过期，false 为过期。 |
| `timeToIdleSeconds` 属性   | 用于设置对象处于空闲状态的最大秒数。                |
| `timeToLiveSeconds` 属性   | 用于设置对象处于缓存状态的最大秒数。                |
| `overflowToDisk` 属性      | 用于设置内存溢出时是否将溢出对象写入硬盘。          |

### 查询缓存

> 默认情况下，设置的缓存对HQL及QBC查询是无效的，但可以通过以下方式使其有效
>
> >1、声明开启查询缓存
> >
> >`<property name="cache.use_query_cache">true</property>`
>
> >2、调用Query 或  Criteria 的 setCacheable(true)
>
> 查询缓存依赖于二级缓存



### 时间戳缓存

> 时间戳缓存区域存放了对于查询结果相关的表进行插入, 更新或删除操作的时间戳.
> Hibernate 通过时间戳缓存区域来判断被缓存的查询结果是否过期, <br/>
> 其运行过程如下: （T1和T2没有规定谁先谁后的，是程序需要操作的） <br/>
> T1 时刻执行查询操作（就例如一个客户1在客户端进行一次查询）, 把查询结果存放在 QueryCache 区域, 记录该区域的时间戳为 T1 <br/>
> T2 时刻对查询结果相关的表进行更新操作（管理员在某个时间对客户查询的表进行了更新操作）, Hibernate 把 T2 时刻存放在 UpdateTimestampCache 区域. <br/>
> T3 时刻执行查询结果前(又有另外一个客户执行了客户1同样的查询语句), 先比较 QueryCache 区域的时间戳（T1）和 UpdateTimestampCache 区域的时间戳(T2), <br/>
> 　　 若 T2 >T1, 那么就丢弃原先存放在 QueryCache 区域的查询结果, 重新到数据库中查询数据, 再把结果存放到 QueryCache 区域; <br/>
> 　　 若 T2 < T1, 直接从 QueryCache 中获得查询结果 <br/>

