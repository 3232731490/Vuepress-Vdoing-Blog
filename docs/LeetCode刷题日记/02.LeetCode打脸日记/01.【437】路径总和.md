---
title: 【437】路径总和Ⅲ
date: 2021-09-28 09:08:54
permalink: /pages/74d1f3/
categories:
  - LeetCode刷题日记
  - LeetCode打脸日记
tags:
  - LeetCode
  - 中等
---

## 题目链接
[437:路径总和Ⅲ🎁](https://leetcode-cn.com/problems/path-sum-iii/)

## 题目描述
> 给定一个二叉树的根节点 root ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 路径 的数目。<br/>
> **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br/>
> 
> 示例 1：<br/>
> ![示例一](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)<br/>
> <br/>
> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<br/>
> 输出：3<br/>
> 解释：和等于 8 的路径有 3 条，如图所示。<br/>
> 示例 2：<br/>
> <br/>
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br/>
> 输出：3<br/>
>  <br/>
> 提示:<br/>
> 二叉树的节点个数的范围是 [0,1000]<br/>
> -10^9 <= Node.val <= 10^9 <br/>
> -1000 <= targetSum <= 1000 <br/>

## 解法一 双DFS
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    using ll = long long;
    int pathSum(TreeNode* root, int targetSum) {  // 递归从当前节点出发有多少条符合要求的路径
        int ans=0;
        int t=0;
        function<void(TreeNode*,ll)> dfs2 = [&](TreeNode* cur,ll temp){
            if(cur==nullptr)
                return;
            if(cur->val==temp)
                t++;
            dfs2(cur->left,temp-cur->val);
            dfs2(cur->right,temp-cur->val);
        };
        function<void(TreeNode*)> dfs1 = [&](TreeNode* cur){  // 递归二叉树的每一个节点作为起始节点
            if(cur==nullptr)
                return;
            dfs2(cur->left,targetSum-cur->val);
            dfs2(cur->right,targetSum-cur->val);
            if(cur->val==targetSum)
                t++;
            ans += t;
            t=0;
            dfs1(cur->left);
            dfs1(cur->right);
        };
        dfs1(root);
        return ans;
    }
};
```
> 执行用时：**84 ms**, 在所有 C++ 提交中击败了`5.31%`的用户<br/>
> 内存消耗：**15.5 MB**, 在所有 C++ 提交中击败了`48.15%`的用户


## 解法二 前缀和
```c++
class Solution {
public:
    using ll = long long;
    unordered_map<ll,int> hash;
    int pathSum(TreeNode* root, int targetSum) {
        int ans=0;
        hash[0]=1;  // 开始空路径时的路径数为1
        function<void(TreeNode*,int)> dfs = [&](TreeNode* cur,ll temp){
            if(cur==nullptr)
                return;
            ll curr = cur->val+temp;  // 将当前节点的值加入到前缀和中
            if(hash.find(curr-targetSum)!=hash.end()){  // 判断前方路径中是否存在值为curr-targetSum的子路径
                ans+=hash[curr-targetSum];  // 如果有则答案加上子路径的条数
            }
            hash[curr]++; // 将当前节点加入到前缀和开始下一次递归
            dfs(cur->left,curr);
            dfs(cur->right,curr);
            hash[curr]--; // 将当前节点退回
        };
        dfs(root,0);
        return ans;
    }
};
```
> 执行用时：**12 ms**, 在所有 C++ 提交中击败了`93.60%`的用户<br/>
> 内存消耗：**18.8 MB**, 在所有 C++ 提交中击败了`23.38%`的用户

## 本题点评
> 感觉难度并不大，但是就是差那么一点想出来<br/>
> 思路是别人给的，代码自己写的，我好菜🤦‍♂️...<br/>
> 就权当时最近刷题懈怠的原因👩‍🦼<br/>
> 没关系，继续加油，今天也是元气满满的一天🤴🏽🚛<br/>