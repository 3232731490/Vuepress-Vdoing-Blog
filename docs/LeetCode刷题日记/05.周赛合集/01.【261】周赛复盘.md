---
title: 【261】周赛复盘
date: 2021-10-03 13:23:47
permalink: /pages/124bf2/
categories:
  - LeetCode刷题日记
  - 周赛合集
tags:
  - LeetCode
  - 周赛
---

## 复盘第【261】常周赛🎉

> 本场周赛整体难度中等偏上(当然只讨论前三题，小菜鸡不配做第四题)，主要难度体现在思维上（特☞第三题），以下为前三题的做题思路

### 【1】转换字符串的最少操作次数🥽

#### 题目链接

[5890. 转换字符串的最少操作次数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/minimum-moves-to-convert-string/comments/)

#### 题目描述👕

> 给你一个字符串 s ，由 n 个字符组成，每个字符不是 'X' 就是 'O' 。<br/>
>
> 一次 操作 定义为从 s 中选出 三个连续字符 并将选中的每个字符都转换为 'O' 。注意，如果字符已经是 'O' ，只需要保持 不变 。<br/>
>
> 返回将 s 中所有字符均转换为 'O' 需要执行的 最少 操作次数。<br/>
>
>  <br/>
>
> 示例 1：<br/>
>
> 输入：s = "XXX"<br/>
> 输出：1<br/>
> 解释：XXX -> OOO<br/>
> 一次操作，选中全部 3 个字符，并将它们转换为 'O' 。<br/><br/>
> 示例 2：<br/>
>
> 输入：s = "XXOX"<br/>
> 输出：2<br/>
> 解释：XXOX -> OOOX -> OOOO<br/>
> 第一次操作，选择前 3 个字符，并将这些字符转换为 'O' 。<br/>
> 然后，选中后 3 个字符，并执行转换。最终得到的字符串全由字符 'O' 组成。<br/><br/>
> 示例 3：<br/>
>
> 输入：s = "OOOO"<br/>
> 输出：0<br/>
> 解释：s 中不存在需要转换的 'X' 。

#### 解法：暴力即可🎗

> 遍历整个字符串，如果当前为“X”，则从当前位置数到往前三个字符都可以变成“O”，所以直接从这里跳到后三个字符的位置继续遍历，答案++；

```cpp
class Solution {
public:
    int minimumMoves(string s) {
        int ans =0;
        int len = s.size();
        for(int i=0;i<len;i++){
            if(s[i]=='X'){
                i+=2;
                ans++;
            }
        }
        return ans;
    }
};
```

> 简单题，一次AC

### 【2】找出缺失的观测数据🎆

#### 题目链接

[5891. 找出缺失的观测数据 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-missing-observations/)

#### 题目描述👟

> 现有一份 n + m 次投掷单个 六面 骰子的观测数据，骰子的每个面从 1 到 6 编号。观测数据中缺失了 n 份，你手上只拿到剩余 m 次投掷的数据。幸好你有之前计算过的这 n + m 次投掷数据的 平均值 。<br/>
>
> 给你一个长度为 m 的整数数组 rolls ，其中 rolls[i] 是第 i 次观测的值。同时给你两个整数 mean 和 n 。<br/>
>
> 返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。<br/>
>
> k 个数字的 平均值 为这些数字求和后再除以 k 。<br/>
>
> 注意 mean 是一个整数，所以 n + m 次投掷的总和需要被 n + m 整除。<br/>
>
>  <br/>
>
> 示例 1：<br/>
>
> 输入：rolls = [3,2,4,3], mean = 4, n = 2<br/>
> 输出：[6,6]<br/>
> 解释：所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。<br/><br/>
> 示例 2：<br/>
>
> 输入：rolls = [1,5,6], mean = 3, n = 4<br/>
> 输出：[2,3,2,2]<br/>
> 解释：所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。<br/><br/>
> 示例 3：<br/>
>
> 输入：rolls = [1,2,3,4], mean = 6, n = 4<br/>
> 输出：[]<br/>
> 解释：无论丢失的 4 次数据是什么，平均值都不可能是 6 。<br/><br/>
> 示例 4：<br/>
>
> 输入：rolls = [1], mean = 3, n = 1<br/>
> 输出：[5]<br/>
> 解释：所有 n + m 次投掷的平均值是 (1 + 5) / 2 = 3 。<br/>
>
>
> 提示：<br/>
>
> m == rolls.length<br/>
> 1 <= n, m <= 10^5^<br/>
> 1 <= rolls[i], mean <= 6<br/>

#### 解法：直接计算👔

> 通过平均值以及数组长度，计算出所有筛子的点数和，然后得到缺失的筛子的总和，计算每个筛子的平均点数，再把多余的点数平均加到筛子上即可

```cpp
class Solution {
public:
    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {
        int len = rolls.size();
        int sum = mean * (len+n);
        int cur = accumulate(begin(rolls),end(rolls),0);
        
        int avg = (sum-cur) / n;
        if(avg<=0||avg>6||(avg==6&&(sum-cur-n*avg)!=0)){
            return {};
        }
        
        vector<int> ans (n,avg);
        for(int i=0;i<sum-cur-n*avg;i++){
            ans[i]+=1;
        }
        return ans;
    }
};
```

> 有些细节没处理好，导致wa了一次



### 【3】石子游戏Ⅳ🧵

> 博弈论---一生之敌，赛场上没做出来这题，赛场上没想明白，看别人题解的时候又觉得我又行了，呜呜，太菜了我

#### 题目链接🛒

[5892. 石子游戏 IX - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/stone-game-ix/)

#### 题目描述🎍

>Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。<br/>
>
>Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。<br/>
>
>如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。<br/>
>如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。<br/>
>假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。<br/>
>
> <br/>
>
>示例 1：<br/>
>
>输入：stones = [2,1]<br/>
>输出：true<br/>
>解释：游戏进行如下：<br/>
>
>- 回合 1：Alice 可以移除任意一个石子。<br/>
>- 回合 2：Bob 移除剩下的石子。 <br/>
>  已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。<br/><br/>
>  示例 2：<br/>
>
>输入：stones = [2]<br/>
>输出：false<br/>
>解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。<br/> 
>由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。<br/><br/>
>示例 3：<br/>
>
>输入：stones = [5,1,2,4,3]<br/>
>输出：false<br/>
>解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：<br/>
>
>- 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。<br/>
>- 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。<br/>
>- 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。<br/>
>- 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.<br/>
>- 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.<br/>
>  Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。<br/>
>
>
>提示：<br/>
>
>1 <= stones.length <= 10^5^<br/>
>1 <= stones[i] <= 10^4^<br/>



#### 解法：博弈&贪心🎨

> 首先把石子按照与3取模后分成0，1，2三类，考虑第一次取石子，如果第一次取0类的直接就输，所以先不考虑取0的情况<br/>
>
> 若第一次取1，则Bob只能取1，紧接着Alice只能取2，接着Bob只能取1....，在不考虑取0的情况下，取石子的序列是固定的112121212....，对于0的情况，0不会增加选的石子与3取模的情况，所以不管0在什么时候取都是可以的，所以最终回合数一共有 1 + 2*min(set(1)-1,set(2)) + set(0)，考虑这个回合总数为奇数且还有剩余石子时，即Alice取了最后一个符合条件的石头，下一个Bob取则Bob比输；若Alice取完最后一个石子且没有剩余石子了，则Bob胜<br/>
>
> 若第一次取2，根据以上类似分析，取石子固定序列为2212121.....，所以总回合数为1+2*min(set(2)-1,set(1))+set(0)，接着就按上述同样的考虑，即可得到最终答案

```cpp
class Solution {
public:
    bool stoneGameIX(vector<int>& s) {
        int len = s.size();
        int record[3];
        memset(record,0,sizeof(record));
        for(auto i : s){
            record[i%3]++;
        }
        function<bool(int,int,int)> check = [&](int _0,int _1,int _2){
            _1--;
            int cur = _0 + 2 * min(_1,_2) + 1;
            if(_1 >_2){
                _1--;
                cur++;
            }
            if(cur == len)  return false;
            return (cur < len && cur & 1) ;
        };
        bool flag = false;
        if(record[1]>0)
            flag = check(record[0],record[1],record[2]);
        if(record[2]>0&&!flag){
            flag = check(record[0],record[2],record[1]);
        }
        return  flag ;
    }
};
```

> 整体来看，本次做的不是很理想，第三题应该要做出来的，下次继续努力，估计国庆大家都去玩了？参赛的人好少...
>
> ![image-20211003132158869](/img/261周赛.png)


