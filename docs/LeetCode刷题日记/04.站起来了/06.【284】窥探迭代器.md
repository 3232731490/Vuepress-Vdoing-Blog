---
title: 【284】窥探迭代器
date: 2021-10-05 09:31:37
permalink: /pages/15397b/
categories:
  - LeetCode刷题日记
  - 站起来了
tags:
  - LeetCode
  - 中等
---
## 题目链接🎞

[284. 窥探迭代器 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/peeking-iterator/)



## 题目描述💚

> 请你设计一个迭代器，除了支持 hasNext 和 next 操作外，还支持 peek 操作。<br/>
>
> 实现 PeekingIterator 类：<br/>
>
> PeekingIterator(int[] nums) 使用指定整数数组 nums 初始化迭代器。<br/>
> int next() 返回数组中的下一个元素，并将指针移动到下个元素处。<br/>
> bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。<br/>
> int peek() 返回数组中的下一个元素，但 不 移动指针。<br/><br/>
>
>
> 示例：<br/>
>
> 输入：<br/>
> ["PeekingIterator", "next", "peek", "next", "next", "hasNext"]<br/>
> [[[1, 2, 3]], [], [], [], [], []]<br/>
> 输出：<br/>
> [null, 1, 2, 2, 3, false]<br/><br/>
>
> 解释：<br/>
> PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]<br/>
> peekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,2,3]<br/>
> peekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,2,3]<br/>
> peekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,3]<br/>
> peekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]<br/>
> peekingIterator.hasNext(); // 返回 False<br/><br/>
>
>
> 提示：<br/>
>
> 1 <= nums.length <= 1000<br/>
> 1 <= nums[i] <= 1000<br/>
> 对 next 和 peek 的调用均有效<br/>
> next、hasNext 和 peek 最多调用  1000 次<br/>



## 解法：模拟即可💤

```cpp
/*
 * Below is the interface for Iterator, which is already defined for you.
 * **DO NOT** modify the interface for Iterator.
 *
 *  class Iterator {
 *		struct Data;
 * 		Data* data;
 *  public:
 *		Iterator(const vector<int>& nums);
 * 		Iterator(const Iterator& iter);
 *
 * 		// Returns the next element in the iteration.
 *		int next();
 *
 *		// Returns true if the iteration has more elements.
 *		bool hasNext() const;
 *	};
 */

class PeekingIterator : public Iterator {
    struct Data{
        int val;
        Data * next;
        Data(int _val):val(_val),next(nullptr){}
    };
public:
    Data* head;
	PeekingIterator(const vector<int>& nums) : Iterator(nums) {
	    // Initialize any member here.
	    // **DO NOT** save a copy of nums and manipulate it directly.
	    // You should only use the Iterator interface methods.
	    head = new Data(-1);
	    Data* pre = head;
	    Data* cur =head;
	    for(auto i:nums){
	        pre= cur;
	        cur->next = new Data(i);
	        cur=cur->next;
	    }
	    
	}
	
    // Returns the next element in the iteration without advancing the iterator.
	int peek() {
    return head->next->val;
	}
	
	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	int next() {
	    head=head->next;
	    return head->val;
	}
	
	bool hasNext() const {
	    return head->next!=nullptr;
	}
};
```



## 感想💨

> 2021-10-5，今天心情一般，无感想，贴个鸡汤吧，加油！！
>
> > ***当你停下脚步时，别忘了别人还在跑***

