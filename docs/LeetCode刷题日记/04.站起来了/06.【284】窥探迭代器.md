---
title: ã€284ã€‘çª¥æ¢è¿­ä»£å™¨
date: 2021-10-05 09:31:37
permalink: /pages/15397b/
categories:
  - LeetCodeåˆ·é¢˜æ—¥è®°
  - ç«™èµ·æ¥äº†
tags:
  - LeetCode
  - ä¸­ç­‰
---
## é¢˜ç›®é“¾æ¥ğŸ

[284. çª¥æ¢è¿­ä»£å™¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)](https://leetcode-cn.com/problems/peeking-iterator/)



## é¢˜ç›®æè¿°ğŸ’š

> è¯·ä½ è®¾è®¡ä¸€ä¸ªè¿­ä»£å™¨ï¼Œé™¤äº†æ”¯æŒ hasNext å’Œ next æ“ä½œå¤–ï¼Œè¿˜æ”¯æŒ peek æ“ä½œã€‚<br/>
>
> å®ç° PeekingIterator ç±»ï¼š<br/>
>
> PeekingIterator(int[] nums) ä½¿ç”¨æŒ‡å®šæ•´æ•°æ•°ç»„ nums åˆå§‹åŒ–è¿­ä»£å™¨ã€‚<br/>
> int next() è¿”å›æ•°ç»„ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶å°†æŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸ªå…ƒç´ å¤„ã€‚<br/>
> bool hasNext() å¦‚æœæ•°ç»„ä¸­å­˜åœ¨ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚<br/>
> int peek() è¿”å›æ•°ç»„ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œä½† ä¸ ç§»åŠ¨æŒ‡é’ˆã€‚<br/><br/>
>
>
> ç¤ºä¾‹ï¼š<br/>
>
> è¾“å…¥ï¼š<br/>
> ["PeekingIterator", "next", "peek", "next", "next", "hasNext"]<br/>
> [[[1, 2, 3]], [], [], [], [], []]<br/>
> è¾“å‡ºï¼š<br/>
> [null, 1, 2, 2, 3, false]<br/><br/>
>
> è§£é‡Šï¼š<br/>
> PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]<br/>
> peekingIterator.next();    // è¿”å› 1 ï¼ŒæŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´  [1,2,3]<br/>
> peekingIterator.peek();    // è¿”å› 2 ï¼ŒæŒ‡é’ˆæœªå‘ç”Ÿç§»åŠ¨ [1,2,3]<br/>
> peekingIterator.next();    // è¿”å› 2 ï¼ŒæŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´  [1,2,3]<br/>
> peekingIterator.next();    // è¿”å› 3 ï¼ŒæŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´  [1,2,3]<br/>
> peekingIterator.hasNext(); // è¿”å› False<br/><br/>
>
>
> æç¤ºï¼š<br/>
>
> 1 <= nums.length <= 1000<br/>
> 1 <= nums[i] <= 1000<br/>
> å¯¹ next å’Œ peek çš„è°ƒç”¨å‡æœ‰æ•ˆ<br/>
> nextã€hasNext å’Œ peek æœ€å¤šè°ƒç”¨  1000 æ¬¡<br/>



## è§£æ³•ï¼šæ¨¡æ‹Ÿå³å¯ğŸ’¤

```cpp
/*
 * Below is the interface for Iterator, which is already defined for you.
 * **DO NOT** modify the interface for Iterator.
 *
 *  class Iterator {
 *		struct Data;
 * 		Data* data;
 *  public:
 *		Iterator(const vector<int>& nums);
 * 		Iterator(const Iterator& iter);
 *
 * 		// Returns the next element in the iteration.
 *		int next();
 *
 *		// Returns true if the iteration has more elements.
 *		bool hasNext() const;
 *	};
 */

class PeekingIterator : public Iterator {
    struct Data{
        int val;
        Data * next;
        Data(int _val):val(_val),next(nullptr){}
    };
public:
    Data* head;
	PeekingIterator(const vector<int>& nums) : Iterator(nums) {
	    // Initialize any member here.
	    // **DO NOT** save a copy of nums and manipulate it directly.
	    // You should only use the Iterator interface methods.
	    head = new Data(-1);
	    Data* pre = head;
	    Data* cur =head;
	    for(auto i:nums){
	        pre= cur;
	        cur->next = new Data(i);
	        cur=cur->next;
	    }
	    
	}
	
    // Returns the next element in the iteration without advancing the iterator.
	int peek() {
    return head->next->val;
	}
	
	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	int next() {
	    head=head->next;
	    return head->val;
	}
	
	bool hasNext() const {
	    return head->next!=nullptr;
	}
};
```



## æ„Ÿæƒ³ğŸ’¨

> 2021-10-5ï¼Œä»Šå¤©å¿ƒæƒ…ä¸€èˆ¬ï¼Œæ— æ„Ÿæƒ³ï¼Œè´´ä¸ªé¸¡æ±¤å§ï¼ŒåŠ æ²¹ï¼ï¼
>
> > ***å½“ä½ åœä¸‹è„šæ­¥æ—¶ï¼Œåˆ«å¿˜äº†åˆ«äººè¿˜åœ¨è·‘***

